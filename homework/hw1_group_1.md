# Solvable Groups in Lean

The materials about solvable group are written in path `Mathlib.GroupTheory.Solvable` inside Mathlib. It consists of only one file `Mathlib/GroupTheory/Solvable.lean` inside its parent directory `Mathlib.GroupTheory`.

This file covers the basic definition, properties, theorems about derived sequence, commutator and solvable groups. It works depending on preliminary files about finite sets, vectors, group theory, ordered sets. Specifically, the beginning of this file imported 5 dependencies to prove basic facts about solvable groups.

```lean
public import Mathlib.Data.Fin.VecNotation
public import Mathlib.GroupTheory.Abelianization.Defs
public import Mathlib.GroupTheory.Perm.ViaEmbedding
public import Mathlib.GroupTheory.Subgroup.Simple
public import Mathlib.SetTheory.Cardinal.Order
``` 

## Main Definitions

### Derived Series

In group theory, the derived series plays a great role in the study of solvable groups, which is defined as an iteration of commutator subgroups. Specifically, assume that `G` is a group, then its first derived group is defined as the commutator subgroup `G' := [G, G],` the second derived group is defined as the commutator subgroup of the first derived group: `G'' := [G', G']`, and so on, which is to say `G⁽ᵏ⁺¹⁾ := [G⁽ᵏ⁾, G⁽ᵏ⁾]`. We name `G⁽ᵏ⁾` as the k-th derived group of `G`, while `G` itself is the zeroth derived group.

Derived series are used to define the solvable property for groups in Mathlib. Some properties of derived series are introduced to Mathlib, including antimonotonicity, normality and characteristicity of the series, along with some properties under homomorphisms.

Convention:

```lean
variable {G G' : Type*} [Group G] [Group G'] {f : G →* G'}
variable (G)
```

#### Commutator Subgroup

Before the definition of derivedSeries, we need to formalize commutator and commutator subgroups. Certainly, Mathlib has already done that:

```lean
/- Bracket a b is denoted by ⁅a, b⁆. -/
instance commutatorElement {G : Type*} [Group G] : Bracket G G :=
  ⟨fun g₁ g₂ ↦ g₁ * g₂ * g₁⁻¹ * g₂⁻¹⟩

/- Closure is the subgroup generated by a subset. -/
def closure (k : Set G) : Subgroup G :=
  sInf { K | k ⊆ K } -- sInf stands for the infimum of a set.

/- ⁅H₁, H₂⁆ is the subgroup generated by the commutators. -/
instance commutator : Bracket (Subgroup G) (Subgroup G) :=
  ⟨fun H₁ H₂ => closure { g | ∃ g₁ ∈ H₁, ∃ g₂ ∈ H₂, ⁅g₁, g₂⁆ = g }⟩

/- commutator G is the commutator subgroup of G. -/
def commutator : Subgroup G := ⁅(⊤ : Subgroup G), ⊤⁆
```

We now look at a direct example that commutative groups have trivial commutator subgroups:

```lean
-- theorem commutator_le : ⁅H₁, H₂⁆ ≤ H₃ ↔ ∀ g₁ ∈ H₁, ∀ g₂ ∈ H₂, ⁅g₁, g₂⁆ ∈ H₃

-- theorem mem_bot {x : G} : x ∈ (⊥ : Subgroup G) ↔ x = 1

theorem commutator_eq_bot_of_comm (h : ∀ a b : G, a * b = b * a) 
        : commutator G = ⊥ := by
  rw[commutator_def]                                 -- ⊢ ⁅⊤, ⊤⁆ = ⊥
  rw [eq_bot_iff, commutator_le]                     -- ⊢ ∀ g₁ ∈ ⊤, ∀ g₂ ∈ ⊤, ⁅g₁, g₂⁆ ∈ ⊥
  intro g₁ _ g₂ _                                    -- g₁ g₂ : G, ⊢ ⁅g₁, g₂⁆ ∈ ⊥
  rw[mem_bot, commutatorElement_eq_one_iff_mul_comm] -- g₁ * g₂ = g₂ * g₁
  exact h g₁ g₂
```

#### Definition

The term `derivedSeries` is an inductive function of a group `G`, defined from natural numbers to subgroups of `G`, obtained by starting from the top subgroup ⊤ and repeatedly taking the commutator of the previous subgroup with itself for n times.

```lean
def derivedSeries : ℕ → Subgroup G
  | 0 => ⊤
  | n + 1 => ⁅derivedSeries n, derivedSeries n⁆
```

By definition, one can derive the n-th term of the derived series:

```lean
theorem derivedSeries_zero : derivedSeries G 0 = ⊤ := rfl
```

```lean
theorem derivedSeries_succ (n : ℕ) :
    derivedSeries G (n + 1) = ⁅derivedSeries G n, derivedSeries G n⁆ := rfl
```

```lean
theorem derivedSeries_one : derivedSeries G 1 = commutator G := rfl
```

#### How to Use Derived Series

- One can access the n-th derived group by `derivedSeries G n`.

#### Example : Derived Series of Commutative Groups

We will prove that a non-zeroth derived group of a commutative group is trivial:

```lean
-- theorem commutator_eq_bot_of_comm (h : ∀ a b : G, a * b = b * a) : commutator G = ⊥

-- theorem commutator_bot_right : ⁅H₁, ⊥⁆ = (⊥ : Subgroup G)

theorem comm_derivedSeries_eq_bot (hn : n ≠ 0) (h : ∀ a b : G, a * b = b * a)
        : derivedSeries G n = ⊥ := by
  induction n with
  | zero => exfalso; exact hn rfl
  | succ k hk =>                        -- k + 1 ≠ 0, ⊢ derivedSeries G (k + 1) = ⊥
  by_cases! hc : k = 0                  -- hc : k = 0 and hc : k ≠ 0
  · rw[hc, zero_add, derivedSeries_one] -- hc : k = 0, ⊢ commutator G = ⊥
    exact commutator_eq_bot_of_comm G h
  · rw[derivedSeries_succ]              -- ⊢ ⁅derivedSeries G k, derivedSeries G k⁆ = ⊥
    rw[hk hc]                           -- hk : k ≠ 0 → derivedSeries G k = ⊥
                                        -- hc : k ≠ 0, ⊢ ⁅⊥, ⊥⁆ = ⊥ 
    exact commutator_bot_right ⊥
```

### Solvable Groups

Solvable groups are defined to be the groups whose derived series is eventually trivial. In fact, there are some equivalent definition. As an example, `G` has a normal series whose factor groups are abelian if and only if `G` is solvable. The definition by derived series is the easiest one to work with, however, for its simple construction.

Generally speaking, solvability is a good property. Similar to the study of Artinian rings and Notherian rings, by considering exact sequences, one can prove that solvabilitily still holds for subgroups, quotient groups, and finite direct products of solvable groups.

#### The IsSolvable TypeClass

Mathlib uses `IsSolvable` typeclass to describe solvability. The typeclass carries a `Prop` named `solvable`, manifesting the existence of a trivial derived group.

```lean
@[mk_iff isSolvable_def]
class IsSolvable : Prop where
  solvable : ∃ n : ℕ, derivedSeries G n = ⊥
```

(It is worth noting that the `Prop where` term indicates that the typeclass `IsSolvable` is of type `Prop`, and hence every instance a proof of the `Prop` element, which is `solvable` here.)

The annotation derives a theorem version of the definition:

```lean
theorem isSolvable_def(G : Type u_1) [Group G] : IsSolvable G ↔ ∃ (n : ℕ), derivedSeries G n = ⊥
```

As a property naturally holds for many groups, a enumeration of instances of `IsSolvable` is given as follows:

- `CommGroup.isSolvable`
- `IsNilpotent.to_isSolvable`
- `IsZGroup.instIsSolvableOfFinite`
- `isSolvable_of_subsingleton`
- `solvable_prod`
- `solvable_quotient_of_solvable`
- `subgroup_solvable_of_solvable`

Some of them will be proven soon.

#### How to Use Solvable Groups

- Since `IsSolvable.solvable` is an existence proposition, we can use `rcases` or `obtain` tactic toextract.
- `IsSolvable.solvable` is an instance in many groups, and one can therefore use theorems of solvable, for these groups.

#### Example : Commutative Groups are Solvable

There are two theorems proving this, named `isSolvable_of_comm` and `isSolvable_of_comm'`, while we are doing it again.

The first approach is to use `use` tactic.

```lean
-- theorem comm_derivedSeries_eq_bot (hn : n ≠ 0) (h : ∀ a b : G, a * b = b * a) : derivedSeries G n = ⊥

theorem isSolvable_of_comm'' (h : ∀ a b : G, a * b = b * a) : IsSolvable G := by
  use 1                                    -- ⊢ derivedSeries G 1 = ⊥
  let : 1 ≠ 0 := by exact Nat.one_ne_zero
  exact comm_derivedSeries_eq_bot G this h
```

The second approach is to use `infer_instance` tactic. (Warning: The following proof has no variable claim, against the convention, since `[CommGroup G]` already provides a group structure on `G`.)

```lean
theorem isSolvable_of_comm''' [CommGroup G] : IsSolvable G := by
  infer_instance
```

## Main Theorems

### map_derivedSeries_le_derivedSeries
We often study the solvability of certain group by considering a group homomorphism between it and some other groups with known properties. 

Let `f` be a group homomorphism from `G` to `G'` . For any natural number n, the image of the n-th term of the derived series of `G` under `f` is a subgroup of  the n-th term of the derived series of `G'`.

```lean
theorem map_derivedSeries_le_derivedSeries {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] (f : G →* G') (n : ℕ) :
Subgroup.map f (derivedSeries G n) ≤ derivedSeries G' n
```
If we #check its type, we will get:

```lean
∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] (f : G →* G') (n : ℕ),
  map f (derivedSeries G n) ≤ derivedSeries G' n
```

Here's a simple example of using it:
```lean
example (G G' : Type*) [Group G] [Group G'] (f : G →* G') (n : ℕ) :
Subgroup.map f (derivedSeries G n) ≤ derivedSeries G' n := by
exact map_derivedSeries_le_derivedSeries f n
```
We have some sufficient/necessary conditions for a group to be solvable.
### isSolvable_of_comm 
If a group `G` is commutative, then it is solvable.

```lean
theorem isSolvable_of_comm {G : Type u_3} [hG : Group G]
(h : ∀ (a b : G), a * b = b * a) : IsSolvable G
```
### solvable_of_ker_le_range
If `f : G'  → G `and `g : G → G'' `are group homomorphisms, and `G' ` and ` G'' `are solvable groups, and the kernel of `g` is a subgroup of the image of `f`, then `G` is also a solvable group.

```lean
theorem solvable_of_ker_le_range {G : Type u_1} [Group G] {G' : Type u_3} {G'' : Type u_4} [Group G'] [Group G''] (f : G' →* G) (g : G →* G'') (hfg : g.ker ≤ f.range) [hG' : IsSolvable G'] [hG'' : IsSolvable G''] :
IsSolvable G
```
### solvable_of_solvable_injective
If `G'` is a solvable group and `f : G →* G'` is an injective group homomorphism, then `G` is a solvable group.
```lean
theorem solvable_of_solvable_injective {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {f : G →* G'} (hf : Function.Injective ⇑f) [IsSolvable G'] :
IsSolvable G
```
### solvable_of_surjective

If `f : G →* G'` is a surjective group homomorphism and `G` is a solvable group, then `G'` is also a solvable group.
```lean
theorem solvable_of_surjective {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {f : G →* G'} (hf : Function.Surjective ⇑f) [IsSolvable G] :
IsSolvable G'
```

### IsNilpotent.to_isSolvable
A nilpotent subgroup is solvable 
```lean
IsNilpotent.to_isSolvable {G : Type u_1} [Group G] [h : Group.IsNilpotent G] : IsSolvable G
```

A conclusion from solvable:
### IsSolvable.commutator_lt_of_ne_bot
In a solvable group `G`, if `H` is a nontrivial subgroup, then the commutator subgroup `⁅H, H⁆` is strictly smaller than `H`.
```lean
theorem IsSolvable.commutator_lt_of_ne_bot {G : Type u_1} [Group G] [IsSolvable G] {H : Subgroup G} (hH : H ≠ ⊥) :
⁅H, H⁆ < H
```

A theorem about proving not solvable:
### not_solvable_of_mem_derivedSeries
If an element `g` of a group `G` , other than the identity element, is contained in every term of the derived series of `G`, then `G` is not solvable.
```lean
theorem not_solvable_of_mem_derivedSeries {G : Type u_1} [Group G] {g : G} (h1 : g ≠ 1) (h2 : ∀ (n : ℕ), g ∈ derivedSeries G n) :
¬IsSolvable G
```

Here's an example of non_solvable groups.
### Equiv.Perm.not_solvable

If the cardinality of a type `X` is greater than or equal to 5, then the group of permutations of `X` is not solvable.

```lean
theorem Equiv.Perm.not_solvable (X : Type u_3) (hX : 5 ≤ Cardinal.mk X) : ¬IsSolvable (Perm X)
```

## Future Directions

The `Solvable.lean` file only contains basic facts about solvable groups, while certain important applications for solvable group are contained in external files of corresponding direction. 

For example, Abel-Ruffini Theorem, the origin introduction of solvable group by Galois, is contained in directory `Mathlib.FieldTheory.AbelRuffini` with statement

```lean
theorem solvableByRad.isSolvable'{F : Type u_1} [Field F] {E : Type u_2} [Field E] [Algebra F E] {α : E} {q : Polynomial F} (q_irred : Irreducible q) (q_aeval : (Polynomial.aeval α) q = 0) (hα : IsSolvableByRad F α) :
IsSolvable q.Gal
```
it gives a external interface to derive the unsolvableness of the Galois group for $\alpha : E / F$ by evidences of ($q$ is irreducible)$\wedge$($q(\alpha)=0$)$\wedge$($\alpha$ can be solved be radical extensions on $F$)

Regrettably, the other direction of AbelRuffini Theorem, which states that solvable Galois group indicates extension elements are solvable by radical extension, hasn't been formalized in lean due to its complexity and strong relativity between group theory and field theorey, which has a huge gap between informal statements and formal codes.
<!-- 可进一步回顾AbelRuffini定理的证明以解释形式化困难 -->

Similiarly, there is a complete basic theory about solvable Lie algebra in `Mathlib.Algebra.Lie.Solvable`, followed by a similiar path: Derived series -> Solvable -> Radical. While the most important part about the correspondence between solvable Lie algbra and Lie group is completely not covered yet. In fact, Mathlib only has partial results about the algebra viewpoint of Lie algebra and differential geometry viewpoint of Lie group, lacking a mature system bridging Lie algebra and Lie group.
<!-- 这也是有限单群分类中将不得不面临的困难 -->

Inside the solvable theory for groups, there are also many things to do in future. There is already a general Jordan–Hölder theorem at the level of lattices in the directory `Mathlib.Order.JordanHolder`

```lean
theorem CompositionSeries.jordan_holder{X : Type u} [Lattice X] [JordanHolderLattice X] (s₁ : CompositionSeries X) (s₂ : CompositionSeries X) (hb : RelSeries.head s₁ = RelSeries.head s₂) (ht : RelSeries.last s₁ = RelSeries.last s₂) :
s₁.Equivalent s₂
```

which establishes uniqueness of length and composition factors in an abstract lattice-theoretic sense. While a specialized version for the composition series of a group should, in principle, recover the classical stating that the successive quotient groups are unique up to permutation and group isomorphism instead of only results at the level of an abstract equivalence predicate `Iso : X × X → X × X → Prop`.

Thus, we still require a group-specific, globally usable version of the Jordan–Hölder theorem that produces concrete algebraic isomorphism data `≃*` or `≃ₗ` and supports transport along homomorphisms. However, different algebraic contexts require different notions of isomorphism and different APIs for transporting composition series along homomorphisms, and a single global instance would necessarily lose this information or lead to instance clashes. Consequently, existing instances are local and context-specific, and further work is required to bridge the abstract lattice-level theorem with concrete group- and module-level formulations.

Finally, in finite group theory, two main theorems characterizing the structure of finite groups by solvable viewpoint: Burnside Lemma (Every finte group of order with at most two prime factors must be solvable), Feit-Thompson Theorem (Every finite group of odd order must be solvable) has not been formalized. The reason for Burnside Lemma is the uncompleteness for representation theory of finite groups in Mathlib, and the reason for Feit-Thompson is its immensitive and profund full proof.